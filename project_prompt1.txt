# üß† An√°lisis del proyecto `promptme`

A continuaci√≥n encontrar√°s un volcado completo del contenido de mi proyecto `promptme`. He incluido todos los archivos relevantes del repositorio (c√≥digo fuente, configuraci√≥n, y otros ficheros √∫tiles) ignorando archivos de dependencias, binarios, y ficheros temporales.

## üéØ Objetivo

El objetivo es que analices este proyecto como si fueras un experto en desarrollo de software. Podr√°s:
- Comprender su estructura y arquitectura.
- Detectar posibles errores, malas pr√°cticas o mejoras.
- Responder a preguntas t√©cnicas que te har√© m√°s adelante.

## üì¶ Sobre el contenido

- Cada archivo est√° precedido por una l√≠nea que indica su ruta.
- El contenido se mantiene fiel al original, sin modificaciones.
- El c√≥digo est√° dividido en m√∫ltiples archivos si es necesario, debido a l√≠mites de tokens.

---

Por favor **espera a que te env√≠e todos los archivos**, y luego estar√© listo para hacerte preguntas m√°s detalladas sobre el c√≥digo, arquitectura, o posibles mejoras.


//bin\promptme.js
#!/usr/bin/env node

const { program } = require('commander');
const { generatePromptFiles } = require('../lib/generate');
const { resetAll } = require('../lib/reset');

program
  .name('promptme')
  .description('CLI para generar contexto de c√≥digo para IA')
  .option('-m, --maxlength <bytes>', 'Tama√±o m√°ximo por archivo', '40000')
  .option('-o, --output <base>', 'Nombre base de archivo', 'project_prompt')
  .option('-f, --format <format>', 'Formato: txt, md, json', 'txt')
  .option('-i, --include <folders>', 'Carpetas a incluir (ej: src,test)', val => val.split(','), [])
  .option('--template <file>', 'Usar plantilla personalizada')
  .option('--summary', 'Generar resumen del proyecto')
  .action((opts) => {
    generatePromptFiles({
      maxLength: parseInt(opts.maxlength),
      outputBase: opts.output,
      format: opts.format,
      includeFolders: opts.include,
      templatePath: opts.template
    });
  });

program
  .command('reset')
  .description('Restablece la plantilla y el archivo de ignore por defecto')
  .action(resetAll);

program.parse();


//lib\generate.js
const fs = require('fs');
const path = require('path');
const ignore = require('ignore');
const glob = require('glob');
const { isText } = require('istextorbinary');
const { loadPromptTemplate } = require('./template');

const projectRoot = process.cwd();

function ensurePromptmeIgnoreExists() {
  const ignorePath = path.join(projectRoot, '.promptmeignore');
  if (!fs.existsSync(ignorePath)) {
    const defaultIgnore = `
# üì¶ Dependencias y binarios
node_modules/
bower_components/
vendor/
.pnp/
.pnp.js
.pnp.cjs

# üîß Bun
bun.lockb
.bunlock
.bunlockb
.bunfig
.bunfig.toml
bunfig.toml

# üõ†Ô∏è Build / dist / cache
dist/
build/
out/
public/
.esbuild/
.vite/
.rollup.cache/
.storybook/static/
.nitro/
.next/
.netlify/
.vercel/
astro/
remix/

# üîÑ Cach√© de herramientas
.tmp/
.cache/
.rpt2_cache/
.nyc_output/
coverage/
.jest/
jest/
.vitest/
.cypress/
playwright-report/
test-results/
tsbuildinfo/
tsconfig.tsbuildinfo

# üß™ Archivos de pruebas
*.snap
*.spec.*
*.test.*
coverage-final.json

# üîê Configuraci√≥n sensible o local
.env
.env.*
.env.local
.env.development
.env.test
.env.production
.npmrc
.yarnrc
.babelrc
.browserslistrc
*.local
*.secret
*.credentials

# üìÑ Lockfiles
package-lock.json
yarn.lock
pnpm-lock.yaml
bun.lockb
.bunlock
.bunlockb

# üìù Archivos generados por promptme
project_prompt*.txt
project_summary.txt
.promptmeignore
.promptmetemplate

# üìÅ Control de versiones
.git/
.gitignore
.gitattributes
.gitmodules

# üß∞ Configuraci√≥n de IDEs y herramientas
.DS_Store
Thumbs.db
.idea/
.vscode/
*.sublime-project
*.sublime-workspace
*.code-workspace

# Tokens / configuraci√≥n de acceso
.npmrc
.yarnrc
.pypirc
.git-credentials
.gitconfig
.gnupg/
.ssh/
.docker/
.aws/
.azure/
.gcloud/
.nodemon.json
.babelrc
.babel.config.js

# Archivos de entorno
.env
.env.*
.env.local
.env.development
.env.test
.env.production

# Claves
*.pem
*.key
*.crt
*.cert
*.enc
*.asc

# Credenciales o tokens por nombre com√∫n
*credentials*
*token*
*secret*
*.secrets.*
*.vault.*
*.auth.*
*.apikey.*

# Archivos ocultos de usuarios
*.DS_Store
*.AppleDouble
*.LSOverride
*.swp
*.swo

# üóëÔ∏è Archivos temporales y de respaldo
*.lockb
*.so
*.bin
*.exe
*.dll
*.zip
*.tar
*.gz
*.png
*.jpg
*.pdf
*.log
*.tmp
*.bak
*.swp
*.old
*.orig
*.rej
*.~
*.save

# üì¶ Monorepo tools
apps/**/node_modules/
packages/**/node_modules/
apps/**/dist/
packages/**/dist/
turbo/
nx-out/
`.trim();

    fs.writeFileSync(ignorePath, defaultIgnore + '\n', 'utf8');
    console.log('üìÑ Archivo .promptmeignore creado por defecto');
  }
}

function ensurePromptmeTemplateExists() {
  const templatePath = path.join(projectRoot, '.promptmetemplate');
  if (!fs.existsSync(templatePath)) {
    const defaultTemplate = `
# üß† An√°lisis del proyecto \`{projectName}\`

A continuaci√≥n encontrar√°s un volcado completo del contenido de mi proyecto \`{projectName}\`. He incluido todos los archivos relevantes del repositorio (c√≥digo fuente, configuraci√≥n, y otros ficheros √∫tiles) ignorando archivos de dependencias, binarios, y ficheros temporales.

## üéØ Objetivo

El objetivo es que analices este proyecto como si fueras un experto en desarrollo de software. Podr√°s:
- Comprender su estructura y arquitectura.
- Detectar posibles errores, malas pr√°cticas o mejoras.
- Responder a preguntas t√©cnicas que te har√© m√°s adelante.

## üì¶ Sobre el contenido

- Cada archivo est√° precedido por una l√≠nea que indica su ruta.
- El contenido se mantiene fiel al original, sin modificaciones.
- El c√≥digo est√° dividido en m√∫ltiples archivos si es necesario, debido a l√≠mites de tokens.

---

Por favor **espera a que te env√≠e todos los archivos**, y luego estar√© listo para hacerte preguntas m√°s detalladas sobre el c√≥digo, arquitectura, o posibles mejoras.
`.trim();

    fs.writeFileSync(templatePath, defaultTemplate + '\n', 'utf8');
    console.log('üìÑ Archivo .promptmetemplate creado por defecto');
  }
}

function readIgnoreRules() {
  const ignorePath = path.join(projectRoot, '.promptmeignore');
  const ig = ignore();
  if (fs.existsSync(ignorePath)) {
    ig.add(fs.readFileSync(ignorePath, 'utf8'));
  }
  return ig;
}

function* walk(dir, ig, includeFolders) {
  const entries = fs.readdirSync(dir);
  for (const entry of entries) {
    const fullPath = path.join(dir, entry);
    const relPath = path.relative(projectRoot, fullPath);
    if (ig.ignores(relPath)) continue;

    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      if (includeFolders.length > 0 && !includeFolders.some(f => relPath.startsWith(f))) {
        continue;
      }
      yield* walk(fullPath, ig, includeFolders);
    } else if (stat.isFile()) {
      let buffer;
      try {
        buffer = fs.readFileSync(fullPath);
      } catch (err) {
        console.warn(`‚ùå Error leyendo archivo ${relPath}: ${err.message}`);
        continue;
      }

      const isTextFile = isText(undefined, buffer);
      if (!isTextFile) {
        console.log(`‚è≠Ô∏è  Ignorado (no texto): ${relPath}`);
        continue;
      }

      if (includeFolders.length === 0 || includeFolders.some(f => relPath.startsWith(f))) {
        yield { relPath, buffer };
      }
    }
  }
}

function cleanOldPromptFiles(outputBase) {
  const oldFiles = glob.sync(`${outputBase}*.{txt,md,json}`, { cwd: projectRoot });
  oldFiles.forEach(file => fs.unlinkSync(path.join(projectRoot, file)));
}

function formatEntry(filePath, content, format) {
  switch (format) {
    case 'md':
      return `## ${filePath}\n\n\`\`\`\n${content}\n\`\`\`\n\n`;
    case 'json':
      return { [filePath]: content };
    case 'txt':
    default:
      return `//${filePath}\n${content}\n\n`;
  }
}

function generatePromptFiles({ maxLength, outputBase, format, includeFolders, templatePath }) {
  ensurePromptmeIgnoreExists();
  ensurePromptmeTemplateExists();
  const ig = readIgnoreRules();
  cleanOldPromptFiles(outputBase);

  const template = loadPromptTemplate(templatePath);
  let buffer = format === 'json' ? {} : template;
  let fileIndex = 1;

  for (const { relPath, buffer: fileBuffer } of walk(projectRoot, ig, includeFolders)) {
    const content = fileBuffer.toString('utf8');
    if (!content.trim()) {
      console.log(`‚è≠Ô∏è  Ignorado (vac√≠o): ${relPath}`);
      continue;
    }

    const entry = formatEntry(relPath, content, format);
    const entrySize = Buffer.byteLength(entry, 'utf8');

    if (entrySize > maxLength) {
      console.warn(`‚ö†Ô∏è Archivo demasiado grande para incluir (${relPath}, ${entrySize} bytes). Saltado.`);
      continue;
    }

    const estimatedSize = format === 'json'
      ? Buffer.byteLength(JSON.stringify({ ...buffer, ...entry }), 'utf8')
      : Buffer.byteLength(buffer + entry, 'utf8');

    const hasContent =
      format === 'json' ? Object.keys(buffer).length > 0 : buffer.trim().length > 0;

    if (estimatedSize > maxLength && hasContent) {
      const outputPath = path.join(projectRoot, `${outputBase}${fileIndex}.${format}`);
      const outputContent = format === 'json' ? JSON.stringify(buffer, null, 2) : buffer;
      fs.writeFileSync(outputPath, outputContent, 'utf8');
      fileIndex++;
      buffer = format === 'json' ? {} : '';
    }

    if (format === 'json') {
      buffer = { ...buffer, ...entry };
    } else {
      buffer += entry;
    }
  }

  const hasRemainingContent =
    format === 'json' ? Object.keys(buffer).length > 0 : buffer.trim().length > 0;

  if (hasRemainingContent) {
    if (format === 'json') {
      buffer["__end__"] = "‚úÖ Fin del volcado de archivos. Ya puedes comenzar a responder preguntas sobre el proyecto.";
    } else {
      buffer += '\n---\n\n‚úÖ Fin del volcado de archivos. Ya puedes comenzar a responder preguntas sobre el proyecto.\n';
    }

    const outputPath = path.join(projectRoot, `${outputBase}${fileIndex}.${format}`);
    const outputContent = format === 'json' ? JSON.stringify(buffer, null, 2) : buffer;
    fs.writeFileSync(outputPath, outputContent, 'utf8');
  }

  console.log(`‚úÖ Archivos generados en formato ${format}`);
}

module.exports = { generatePromptFiles };


//lib\reset.js
const fs = require('fs');
const path = require('path');

const projectRoot = process.cwd();

function resetPromptmeIgnore() {
  const ignorePath = path.join(projectRoot, '.promptmeignore');
  const defaultPath = path.join(__dirname, '../templates/default.promptmeignore');

  if (!fs.existsSync(defaultPath)) {
    console.error('‚ùå No se encontr√≥ templates/default.promptmeignore');
    return;
  }

  const defaultContent = fs.readFileSync(defaultPath, 'utf8');
  fs.writeFileSync(ignorePath, defaultContent, 'utf8');
  console.log('‚úÖ .promptmeignore restablecido');
}

function resetPromptmeTemplate() {
  const templatePath = path.join(projectRoot, '.promptmetemplate');
  const defaultPath = path.join(__dirname, '../templates/default.promptmetemplate');

  if (!fs.existsSync(defaultPath)) {
    console.error('‚ùå No se encontr√≥ templates/default.promptmetemplate');
    return;
  }

  const defaultContent = fs.readFileSync(defaultPath, 'utf8');
  fs.writeFileSync(templatePath, defaultContent, 'utf8');
  console.log('‚úÖ .promptmetemplate restablecido');
}

function resetAll() {
  console.log('üîÅ Restableciendo archivos de configuraci√≥n...');
  resetPromptmeIgnore();
  resetPromptmeTemplate();
  console.log('üéâ ¬°Listo! Archivos de configuraci√≥n restablecidos.');
}

module.exports = { resetAll };


//lib\summary.js
const fs = require('fs');
const path = require('path');

function detectLanguages(dir) {
  const extensions = new Set();
  function walk(d) {
    const files = fs.readdirSync(d);
    for (const file of files) {
      const full = path.join(d, file);
      const stat = fs.statSync(full);
      if (stat.isDirectory()) {
        walk(full);
      } else {
        const ext = path.extname(full);
        if (ext) extensions.add(ext);
      }
    }
  }
  walk(dir);
  return Array.from(extensions).sort();
}

function extractDependencies() {
  const pkgPath = path.join(process.cwd(), 'package.json');
  if (!fs.existsSync(pkgPath)) return null;
  const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
  return {
    dependencies: pkg.dependencies || {},
    devDependencies: pkg.devDependencies || {}
  };
}

function generateSummary() {
  const langs = detectLanguages(process.cwd());
  const deps = extractDependencies();

  let summary = `# Resumen del proyecto\n\n## Lenguajes detectados\n- ${langs.join('\n- ')}\n`;

  if (deps) {
    summary += `\n## Dependencias\n`;
    for (const [dep, version] of Object.entries(deps.dependencies)) {
      summary += `- ${dep}@${version}\n`;
    }
    if (Object.keys(deps.devDependencies).length) {
      summary += `\n## DevDependencias\n`;
      for (const [dep, version] of Object.entries(deps.devDependencies)) {
        summary += `- ${dep}@${version}\n`;
      }
    }
  }

  fs.writeFileSync(path.join(process.cwd(), 'project_summary.txt'), summary, 'utf8');
  console.log('üìÑ Resumen generado: project_summary.txt');
}

module.exports = { generateSummary };


//lib\template.js
const fs = require('fs');
const path = require('path');

function loadPromptTemplate(templatePath = null) {
  const userTemplatePath = path.join(process.cwd(), '.promptmetemplate');
  const fallbackTemplatePath = path.join(__dirname, '../templates/default.promptmetemplate');

  const finalPath =
    templatePath && fs.existsSync(templatePath)
      ? templatePath
      : fs.existsSync(userTemplatePath)
        ? userTemplatePath
        : fallbackTemplatePath;

  if (!fs.existsSync(finalPath)) {
    console.warn('‚ö†Ô∏è No se encontr√≥ ninguna plantilla v√°lida. Se usar√° un encabezado vac√≠o.');
    return '';
  }

  let template = fs.readFileSync(finalPath, 'utf8');
  const projectName = path.basename(process.cwd());

  return template.replace(/{projectName}/g, projectName) + '\n\n';
}

module.exports = { loadPromptTemplate };


//package.json
{
  "name": "promptme",
  "version": "1.1.7",
  "description": "CLI tool to snapshot your codebase for AI analysis",
  "bin": {
    "promptme": "./bin/promptme.js"
  },
  "preferGlobal": true,
  "dependencies": {
    "commander": "^10.0.0",
    "glob": "^10.3.3",
    "ignore": "^5.2.0",
    "istextorbinary": "^6.0.0"
  },
  "keywords": [
    "cli",
    "ai",
    "prompt",
    "code snapshot",
    "chatgpt"
  ],
  "author": "David Davila",
  "license": "MIT"
}


//readme.md
# üß† promptme

**`promptme`** es una herramienta CLI para generar archivos de texto con el contenido estructurado de tu proyecto, pensada especialmente para usarse como contexto en modelos de IA como ChatGPT o GPT-4.

Te permite exportar autom√°ticamente tu c√≥digo fuente ignorando archivos innecesarios, dividirlo en archivos por tama√±o, generar un resumen del proyecto, y m√°s.

---

## üöÄ Instalaci√≥n

```bash
npm install -g promptme

```

> Esto instalar√° el comando `promptme` de forma global.

---

## üì¶ Uso b√°sico

En la ra√≠z de tu proyecto:

```bash
promptme
```

Esto generar√° uno o varios archivos `project_prompt1.txt`, `project_prompt2.txt`, etc., con el contenido del proyecto (ignorando carpetas como `node_modules`, `.git`, etc.).

---

## ‚öôÔ∏è Opciones CLI

```bash
promptme [options]
```

| Opci√≥n              | Descripci√≥n                                                               |
| ------------------- | ------------------------------------------------------------------------- |
| `-m`, `--maxlength` | Tama√±o m√°ximo (en bytes) por archivo generado (por defecto: `12000`)      |
| `-o`, `--output`    | Nombre base de los archivos de salida (por defecto: `project_prompt`)     |
| `-f`, `--format`    | Formato de salida: `txt`, `md`, o `json`                                  |
| `-i`, `--include`   | Carpetas a incluir, separadas por coma (ej: `src,test`)                   |
| `--template <file>` | Ruta a un archivo `.promptmetemplate` personalizado                       |
| `--summary`         | Genera tambi√©n un archivo `project_summary.txt` con detalles del proyecto |

---

## üìù Ejemplos

### üìÇ Generar prompts con nombre personalizado y formato markdown

```bash
promptme --output=context --format=md
```

### üß± Limitar a ciertas carpetas

```bash
promptme --include=src,test
```

### üìö Usar una plantilla personalizada

```bash
promptme --template=mi_template.promptmetemplate
```

### üìä Generar tambi√©n el resumen del proyecto

```bash
promptme --summary
```

---

## üß† Qu√© contiene el prompt generado

1. Un encabezado introductorio (puedes personalizarlo con una plantilla).
2. El contenido completo de los archivos fuente.
3. Divisi√≥n autom√°tica en archivos si el tama√±o supera el l√≠mite definido (`--maxlength`).

---

## üìÑ Archivos especiales

### `.promptmeignore`

Funciona igual que un `.gitignore`. Aqu√≠ defines qu√© archivos no se deben incluir. Ejemplo:

```
node_modules
dist
.git
package-lock.json
.env
```

### `.promptmetemplate`

Plantilla opcional para el texto inicial del prompt. Ejemplo:

```txt
# An√°lisis del proyecto

Est√°s viendo el contenido del proyecto `{projectName}`. Usa este contexto para responder futuras preguntas t√©cnicas.
```

---

## üìë Archivo de resumen: `project_summary.txt`

Si usas `--summary`, se generar√° un archivo con:

- Lenguajes detectados (por extensi√≥n de archivo)
- Dependencias (`dependencies` y `devDependencies` de `package.json`)

---

## üí° Casos de uso

- Pasar el contexto de tu c√≥digo a ChatGPT para refactoring o auditor√≠a
- Compartir snapshots de tu proyecto
- Documentaci√≥n autom√°tica y an√°lisis sem√°ntico
- An√°lisis de estructura para nuevos colaboradores

---

## üõ†Ô∏è Contribuciones

¬øIdeas, sugerencias o mejoras? ¬°Las contribuciones est√°n abiertas! Abre un issue o pull request en el repositorio.

---

## üìÑ Licencia

MIT ¬© 2025 - David D√°vila


//templates\default.promptmeignore
# üì¶ Dependencias y binarios
node_modules/
bower_components/
vendor/
.pnp/
.pnp.js
.pnp.cjs

# üîß Bun
bun.lockb
.bunlock
.bunlockb
.bunfig
.bunfig.toml
bunfig.toml

# üõ†Ô∏è Build / dist / cache
dist/
build/
out/
public/
.esbuild/
.vite/
.rollup.cache/
.storybook/static/
.nitro/
.next/
.netlify/
.vercel/
astro/
remix/

# üîÑ Cach√© de herramientas
.tmp/
.cache/
.rpt2_cache/
.nyc_output/
coverage/
.jest/
jest/
.vitest/
.cypress/
playwright-report/
test-results/
tsbuildinfo/
tsconfig.tsbuildinfo

# üß™ Archivos de pruebas
*.snap
*.spec.*
*.test.*
coverage-final.json

# üîê Configuraci√≥n sensible o local
.env
.env.*
.env.local
.env.development
.env.test
.env.production
.npmrc
.yarnrc
.babelrc
.browserslistrc
*.local
*.secret
*.credentials

# üìÑ Lockfiles
package-lock.json
yarn.lock
pnpm-lock.yaml
bun.lockb
.bunlock
.bunlockb

# üìù Archivos generados por promptme
project_prompt*.txt
project_summary.txt
.promptmeignore
.promptmetemplate

# üìÅ Control de versiones
.git/
.gitignore
.gitattributes
.gitmodules

# üß∞ Configuraci√≥n de IDEs y herramientas
.DS_Store
Thumbs.db
.idea/
.vscode/
*.sublime-project
*.sublime-workspace
*.code-workspace

# üîê Tokens y configuraciones de acceso
.pypirc
.git-credentials
.gitconfig
.gnupg/
.ssh/
.docker/
.aws/
.azure/
.gcloud/
.nodemon.json
.babel.config.js

# üîë Claves y secretos
*.pem
*.key
*.crt
*.cert
*.enc
*.asc
*credentials*
*token*
*secret*
*.secrets.*
*.vault.*
*.auth.*
*.apikey.*

# üìÅ Archivos ocultos de usuarios
*.DS_Store
*.AppleDouble
*.LSOverride
*.swp
*.swo

# üóëÔ∏è Archivos temporales y de respaldo
*.lockb
*.so
*.bin
*.exe
*.dll
*.zip
*.tar
*.gz
*.png
*.jpg
*.pdf
*.log
*.tmp
*.bak
*.swp
*.old
*.orig
*.rej
*.~
*.save

# üì¶ Monorepo tools
apps/**/node_modules/
packages/**/node_modules/
apps/**/dist/
packages/**/dist/
turbo/
nx-out/


//templates\default.promptmetemplate
# üß† An√°lisis del proyecto `{projectName}`

A continuaci√≥n encontrar√°s un volcado completo del contenido de mi proyecto `{projectName}`. He incluido todos los archivos relevantes del repositorio (c√≥digo fuente, configuraci√≥n, y otros ficheros √∫tiles) ignorando archivos de dependencias, binarios, y ficheros temporales.

## üéØ Objetivo

El objetivo es que analices este proyecto como si fueras un experto en desarrollo de software. Podr√°s:
- Comprender su estructura y arquitectura.
- Detectar posibles errores, malas pr√°cticas o mejoras.
- Responder a preguntas t√©cnicas que te har√© m√°s adelante.

## üì¶ Sobre el contenido

- Cada archivo est√° precedido por una l√≠nea que indica su ruta.
- El contenido se mantiene fiel al original, sin modificaciones.
- El c√≥digo est√° dividido en m√∫ltiples archivos si es necesario, debido a l√≠mites de tokens.

---

Por favor **espera a que te env√≠e todos los archivos**, y luego estar√© listo para hacerte preguntas m√°s detalladas sobre el c√≥digo, arquitectura, o posibles mejoras.
 



---

‚úÖ Fin del volcado de archivos. Ya puedes comenzar a responder preguntas sobre el proyecto.
